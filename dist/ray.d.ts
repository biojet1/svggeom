import { Vec } from './point.js';
declare type NumOrVec = number | Iterable<number>;
export declare class VecRay {
    readonly _pos: Vec;
    readonly _dir: Vec;
    constructor(pos: Vec, aim: Vec);
    get x(): number;
    get y(): number;
    get z(): number;
    get h(): number;
    get v(): number;
    get pos(): Vec;
    get dir(): Vec;
    [Symbol.iterator](): Iterator<number>;
    at(): Vec;
    distance(x: NumOrVec, y?: number): number;
    pointAlong(d: number): Vec;
    delta(x: NumOrVec, y?: number): Vec;
    side(x: NumOrVec, y?: number): 0 | 1 | -1;
    distanceFromLine(a: Iterable<number>, b: Iterable<number>): number;
    nearestPointOfLine(a: Iterable<number>, b: Iterable<number>): Vec;
    intersectOfLine(a: Iterable<number>, b: Iterable<number>): Vec;
    intersectOfRay(r: Ray): Vec;
    nearestPointFromPoint(p: Iterable<number>): Vec;
}
export declare class Ray extends VecRay {
    clone(): Ray;
    begin(): RayStack;
    end(): Ray | undefined;
    protected _Pos(v: Vec): Ray;
    protected _Dir(v: Vec): Ray;
    protected _Set(p: Vec, a: Vec): Ray;
    withDir(rad: NumOrVec): Ray;
    withH(h?: number): Ray;
    withV(v?: number): Ray;
    withX(x?: number): Ray;
    withY(y?: number): Ray;
    withZ(z?: number): Ray;
    shiftX(d: number): Ray;
    shiftY(d: number): Ray;
    shiftZ(d: number): Ray;
    flipX(): Ray;
    flipY(): Ray;
    flipZ(): Ray;
    goto(x: NumOrVec, y?: number): Ray;
    forward(d: number): Ray;
    back(d?: number): Ray;
    translate(x: NumOrVec, y?: number): Ray;
    along(t: number, x: NumOrVec, y?: number): Ray;
    turn(rad: NumOrVec): Ray;
    left(rad?: number): Ray;
    right(rad?: number): Ray;
    turnd(deg: number): Ray;
    leftd(deg: number): Ray;
    rightd(deg: number): Ray;
    towards(x: NumOrVec, y?: number): Ray;
    away(x: NumOrVec, y?: number): Ray;
    after(x: NumOrVec, y?: number): Ray;
    before(x: NumOrVec, y?: number): Ray;
    normalToSide(a: Iterable<number>): Ray;
    normalToLine(a: Iterable<number>, b: Iterable<number>): Ray;
    toNearestPointOfLine(a: Iterable<number>, b: Iterable<number>): Ray;
    toNearestPointFromPoint(p: Iterable<number>): Ray;
    toPointT(t: number, a: Iterable<number>, b: Iterable<number>): Ray;
    toMidPoint(a: Iterable<number>, b: Iterable<number>): Ray;
    static new(...args: NumOrVec[]): Ray;
    static pos(x: NumOrVec, y?: number): Ray;
    static at(x: NumOrVec, y?: number): Ray;
    static dir(x: NumOrVec, y?: number): Ray;
    static towards(x: NumOrVec, y?: number): Ray;
    static away(x: NumOrVec, y?: number): Ray;
    static after(x: NumOrVec, y?: number): Ray;
    static before(x: NumOrVec, y?: number): Ray;
    static fromLine(a: Iterable<number>, b: Iterable<number>): Ray;
    static get home(): Ray;
}
export declare class RayStack extends VecRay {
    _prev: Ray;
    constructor(ray: Ray);
    end(): Ray;
}
export declare class RayL extends Ray {
    _prev: Ray | undefined;
    constructor(pos: Vec, dir: Vec, ray?: Ray);
    prev(): Ray | undefined;
    protected _Pos(v: Vec): RayL;
    protected _Dir(v: Vec): RayL;
    protected _Set(p: Vec, a: Vec): RayL;
}
export {};
