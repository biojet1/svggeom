import { dSplit } from './path/parser.js';
import { SegmentSE, DescParams } from './path/index.js';
import { Box } from './box.js';
export declare class Path {
    static digits: number;
    private _segs;
    private _length?;
    private _lengths?;
    private constructor();
    getTotalLength(): number | undefined;
    getBBox(): Box;
    tangentAt(T: number): import("./point.js").Vec | undefined;
    slopeAt(T: number): import("./point.js").Vec | undefined;
    pointAt(T: number): import("./point.js").Vec | undefined;
    bbox(): Box;
    splitAt(T: number): Path[] | undefined;
    cutAt(T: number): Path;
    cropAt(T0: number, T1?: number): Path;
    transform(M: any): Path;
    reversed(): Path;
    get length(): number | undefined;
    get totalLength(): number | undefined;
    pointAtLength(L: number): 0 | import("./point.js").Vec | undefined;
    [Symbol.iterator](): IterableIterator<SegmentSE>;
    private calcLength;
    private get lengths();
    get firstPoint(): import("./point.js").Vec | undefined;
    get firstSegmentSE(): SegmentSE | undefined;
    get lastPoint(): import("./point.js").Vec | undefined;
    get lastSegmentSE(): SegmentSE | undefined;
    segmentAt(T: number): [SegmentSE | undefined, number, number];
    isContinuous(): boolean;
    isClosed(): boolean;
    private enumDesc;
    descArray(params?: DescParams): (string | 0 | 1)[];
    describe(params?: DescParams): string;
    toString(): string;
    enumSubPaths(): Generator<Path, void, unknown>;
    static parse(d: string): Path;
    static new(v?: SegmentSE[] | string | SegmentSE | Path): Path;
}
import { Line } from './path/line.js';
import { Arc } from './path/arc.js';
import { Quadratic } from './path/quadratic.js';
export * from './path/cubic.js';
import { SegmentLS } from './path/linked.js';
export { SegmentLS };
export { Arc, Quadratic, Line, dSplit };
