import { BoundingBox } from './bbox.js';
import { DescParams } from './path/index.js';
export declare class PathSE {
    static digits: number;
    private _segs;
    private _length?;
    private _lengths?;
    private constructor();
    getTotalLength(): number | undefined;
    getBBox(): BoundingBox;
    tangentAt(T: number): import("./vector.js").Vector | undefined;
    slopeAt(T: number): import("./vector.js").Vector | undefined;
    pointAt(T: number): import("./vector.js").Vector | undefined;
    bbox(): BoundingBox;
    splitAt(T: number): PathSE[] | undefined;
    cutAt(T: number): PathSE;
    cropAt(T0: number, T1?: number): PathSE;
    transform(M: any): PathSE;
    reversed(): PathSE;
    get length(): number | undefined;
    get totalLength(): number | undefined;
    pointAtLength(L: number): 0 | import("./vector.js").Vector | undefined;
    [Symbol.iterator](): IterableIterator<SegmentSE>;
    private calcLength;
    private get lengths();
    get start_point(): import("./vector.js").Vector | undefined;
    get firstSegment(): SegmentSE | undefined;
    get end_point(): import("./vector.js").Vector | undefined;
    get from(): import("./vector.js").Vector | undefined;
    get to(): import("./vector.js").Vector | undefined;
    get lastSegment(): SegmentSE | undefined;
    segmentAt(T: number): [SegmentSE | undefined, number, number];
    isContinuous(): boolean;
    isClosed(): boolean;
    private enumDesc;
    descArray(params?: DescParams): (string | 0 | 1)[];
    describe(params?: DescParams): string;
    toString(): string;
    enumSubPaths(): Generator<PathSE, void, unknown>;
    static parse(d: string): PathSE;
    static new(v?: SegmentSE[] | string | SegmentSE | PathSE): PathSE;
}
import { Line } from './path/line.js';
import { Arc } from './path/arc.js';
import { Cubic } from './path/cubic.js';
import { Quadratic } from './path/quadratic.js';
import { dSplit } from './path/parser.js';
import { SegmentSE } from './path/segmentse.js';
export { Arc, Quadratic, Line, Cubic, dSplit };
